/*******************************************************************************
 * PlayState is the game itself. This is called from the menu.
 * 
 * @returns
 */
function PlayState() {

	var sprites = [];
	var ball, player1, player2, direction = 10, originalSpeed = speed = 2.25, rally = 0, net, sfx;

	var fps = $("#fps");

	/*
	 * Called once when a game state is activated. Use it for one-time setup
	 * code.
	 */
	this.setup = function() {

		jaws.on_keydown([ "q" ], function() {
			jaws.switchGameState(MenuState);
		});

		// Create the players.
		player1 = new jaws.Sprite({
			image : "img/bat.png",
			x : 10,
			y : 145,
			anchor : "center"
		});
		player1.score = 0;
		player1.scoreHtml = $("#player1_score");

		player2 = new jaws.Sprite({
			image : "img/bat.png",
			x : 390,
			y : 145,
			anchor : "center"
		});
		player2.score = 0;
		player2.scoreHtml = $("#player2_score");

		sprites.push(player1);
		sprites.push(player2);

		// Now for the ball.
		ball = new jaws.Sprite({
			image : "img/ball.png",
			x : 150 + (Math.random() * 100),
			y : 100 + (Math.random() * 100),
			anchor : "center"
		});

		moveSprite(ball, direction, speed);

		// Create the net - just decoration but it should be there.
		net = new jaws.SpriteList();
		for ( var i = 0; i < jaws.height; i += 15) {
			net.push(new jaws.Sprite({
				image : "img/net.png",
				x : jaws.width / 2,
				y : i
			}));
		}

		// Stop the cursor keys shifting the page when we try to move the bat.
		jaws.preventDefaultKeys([ "up", "down", "left", "right", "space" ]);
	};

	/*
	 * update() will get called each game tick with your specified FPS. Put game
	 * logic here.
	 */
	this.update = function() {

		// Move the players
		if (jaws.pressed('a')) {
			player1.y -= 2;
		} else if (jaws.pressed('z')) {
			player1.y += 2;
		} else if (jaws.pressed('k')) {
			player2.y -= 2;
		} else if (jaws.pressed('m')) {
			player2.y += 2;
		}

		sprites.forEach(function(sprite, index) {
			forceInsideCanvas(sprite);
		});

		// Move the ball.
		ball.collision = false;
		ball.move(ball.vx, ball.vy);

		// Check to see if the ball has hit a paddle.
		var paddleHit = jaws.collideOneWithMany(ball, sprites);
		if (paddleHit.length > 0) {
			// The ball was hit so we increment the rally counter.
			rally += 1;
			if (rally == 5) {
				speed += 0.5;
				rally = 0;
			}

			// Change the value of vx depending on where on the
			// bat the ball hit to give changes of angle.
			var segment = paddleHit[0].height / 8;
			// The ball has hit the top end of the bat so gets an acute angle
			// upwards.
			if (ball.y < paddleHit[0].y - (segment * 3.5)) {
				direction = 295;
			} else if (ball.y < paddleHit[0].y - (segment * 2.5)) {
				direction = 305;
			} else if (ball.y < paddleHit[0].y - (segment * 1.5)) {
				direction = 320;
			} else if (ball.y < paddleHit[0].y - (segment * 0.5)) {
				direction = 340;
			} else if (ball.y < paddleHit[0].y + (segment * 0.5)) {
				// Change to a flat trajectory.
				direction = 355;
			} else if (ball.y < paddleHit[0].y + (segment * 1.5)) {
				direction = 5;
			} else if (ball.y < paddleHit[0].y + (segment * 1.5)) {
				// Now the ball is firmly in the bottom of the bat and so gets a
				// downward angle.
				direction = 35;
			} else if (ball.y < paddleHit[0].y + (segment * 2.5)) {
				// Another step steeper.
				direction = 50;
			} else if (ball.y < paddleHit[0].y + (segment * 3.5)) {
				// Another step steeper.
				direction = 70;
			} else if (ball.y < paddleHit[0].y + (segment * 4.0)) {
				// Another step steeper.
				direction = 85;
			}

			// All the directions above are based on player 1's paddle.
			// If the ball actually hit player 2's paddle then reverse the x
			// direction.
			if (paddleHit[0].x > ball.x) {
				if (direction > 180) {
					direction -= 180;
				} else {
					direction += 180;
				}
				ball.vx = -ball.vx;
				sfx = jaws.assets
						.get("snd/4387__noisecollector__pongblipe4.wav");
				sfx.play();
			} else {
				sfx = jaws.assets
						.get("snd/4390__noisecollector__pongblipf-4.wav");
				sfx.play();
			}

			moveSprite(ball, direction, speed);
		}

		// Might be nice to have it going towards the player who got the point?
		// Check to see if the ball has hit player 1's side.
		if (ball.x < 0) {
			score(player2, "snd/4388__noisecollector__pongblipe5.wav", 0);
		}

		// Check to see if the ball has hit player 2's side.
		if (ball.rect().right > jaws.width) {
			score(player1, "snd/4391__noisecollector__pongblipf-5.wav", 180);
		}

		// Check to see if the ball has hit the top or bottom and bounce it back
		// into the court.
		if (ball.y < 0 || ball.rect().bottom > jaws.height) {
			ball.vy = -ball.vy;
		}

		fps.html(jaws.game_loop.fps);
	};

	/*
	 * Directly after each update draw() will be called. Put all your on-screen
	 * operations here.
	 */
	this.draw = function() {
		jaws.clear();
		net.draw();
		ball.draw();
		sprites.forEach(function(sprite, index) {
			sprite.draw();
		});
	};

	/**
	 * 
	 * @param item
	 */
	function forceInsideCanvas(item) {
		// Don't need this right now as the paddles can only go up and down.
		// if(item.x < 0) { item.x = 0; }
		// if(item.x + item.width > jaws.width) { item.x = jaws.width -
		// item.width; }

		// Work out the half the height of the paddle so its position can be
		// adjusted.
		var overhang = item.height / 2;
		if (item.y - overhang < 0) {
			item.y = overhang;
		}
		if (item.y + overhang > jaws.height) {
			item.y = jaws.height - overhang;
		}
	}

	/**
	 * Could add this function to the sprite then we could just say ball.vector
	 * (move is already used for the actual moving.
	 * 
	 * @param sprite
	 * @param direction
	 * @param speed
	 * @returns {Boolean}
	 */
	function moveSprite(sprite, direction, speed) {

		if (speed < originalSpeed) {
			speed = originalSpeed;
		}
		sprite.vx = Math.cos(direction * (Math.PI / 180)) * speed;
		sprite.vy = Math.sin(direction * (Math.PI / 180)) * speed;
		return true;
	}

	/**
	 * A point has been scored.
	 * 
	 * @param player
	 * @param sound
	 * @param newDirection
	 */
	function score(player, sound, newDirection) {

		sfx = jaws.assets.get(sound);
		sfx.play();

		// The ball was missed so we set the rally counter back to 0.
		rally = 0;

		ball.x = 150 + (Math.random() * 100);
		ball.y = 100 + (Math.random() * 100);
		moveSprite(ball, newDirection, speed);

		player.score += 1;
		player.scoreHtml.html(player.score);
	}
}

/**
 * 
 * MenuState is our lobby/welcome menu were gamer can chose start, high score
 * and settings. For this example we have only implemented start. Start switches
 * active game state by simply: jaws.switchGameState(PlayState)
 * 
 */
function MenuState() {
	var index = 0;
	var items = [ "Start", "Settings", "Highscore" ];

	this.setup = function() {
		index = 0;
		jaws.on_keydown([ "down", "s" ], function() {
			index++;
			if (index >= items.length) {
				index = items.length - 1;
			}
		});
		jaws.on_keydown([ "up", "w" ], function() {
			index--;
			if (index < 0) {
				index = 0;
			}
		});
		jaws.on_keydown([ "enter", "space" ], function() {
			if (items[index] == "Start") {
				jaws.switchGameState(PlayState);
			}
		});
	};

	this.draw = function() {
		jaws.context.clearRect(0, 0, jaws.width, jaws.height);
		for ( var i = 0; items[i]; i++) {
			// jaws.context.translate(0.5, 0.5)
			jaws.context.font = "bold 40pt terminal";
			jaws.context.lineWidth = 10;
			jaws.context.fillStyle = (i == index) ? "Red" : "White";
			jaws.context.strokeStyle = "rgba(200,200,200,0.0)";
			jaws.context.fillText(items[i], 30, 100 + i * 60);
		}
		;
	};
}
